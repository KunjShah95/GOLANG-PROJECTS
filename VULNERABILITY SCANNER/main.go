package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"net"
	"net/http"
	"os"
	"strconv"
	"strings"
	"sync"
	"time"
)

// Struct for storing scan results
type ScanResult struct {
	OpenPorts       []int             `json:"open_ports"`
	Vulnerabilities []string          `json:"vulnerabilities"`
	HTTPFindings    map[string]string `json:"http_findings"`
}

func main() {
	// CLI flags for target, port range, and output file
	target := flag.String("target", "", "Target IP or domain to scan (e.g., 192.168.1.1 or example.com)")
	portRange := flag.String("ports", "1-1024", "Port range to scan (e.g., 1-1024)")
	outputFile := flag.String("output", "scan_results.json", "File to save scan results")
	flag.Parse()

	// Validate input
	if *target == "" {
		fmt.Println("Error: Target is required. Use -target flag to specify.")
		flag.Usage()
		return
	}
	startPort, endPort, err := parsePortRange(*portRange)
	if err != nil {
		fmt.Printf("Invalid port range: %v\n", err)
		return
	}

	fmt.Printf("Scanning %s on ports %d to %d...\n", *target, startPort, endPort)

	// Perform concurrent port scanning
	openPorts := concurrentScanPorts(*target, startPort, endPort)
	if len(openPorts) > 0 {
		fmt.Printf("\nOpen Ports:\n")
		for _, port := range openPorts {
			fmt.Printf("- Port %d: Open\n", port)
		}
	} else {
		fmt.Println("\nNo open ports found.")
	}

	// Initialize result object
	scanResult := ScanResult{
		OpenPorts:    openPorts,
		HTTPFindings: make(map[string]string),
	}

	// Perform concurrent HTTP security checks
	if contains(openPorts, 80) || contains(openPorts, 443) {
		fmt.Println("\nPerforming HTTP security checks...")
		httpFindings := concurrentCheckHTTPVulnerabilities(*target, openPorts)
		for k, v := range httpFindings {
			scanResult.HTTPFindings[k] = v
		}
	}

	// Mock CVE database check
	fmt.Println("\nChecking for vulnerabilities against CVE database...")
	vulnerabilities := checkCVEs(openPorts)
	scanResult.Vulnerabilities = vulnerabilities

	if len(vulnerabilities) > 0 {
		fmt.Println("\nDetected Vulnerabilities:")
		for _, v := range vulnerabilities {
			fmt.Printf("- %s\n", v)
		}
	} else {
		fmt.Println("No vulnerabilities found.")
	}

	// Export results to a JSON file
	exportResults(scanResult, *outputFile)
	fmt.Printf("\nScan complete. Results saved to '%s'.\n", *outputFile)
}

// Parse the port range from user input
func parsePortRange(portRange string) (int, int, error) {
	parts := strings.Split(portRange, "-")
	if len(parts) != 2 {
		return 0, 0, fmt.Errorf("port range must be in the format 'start-end'")
	}
	startPort, err1 := strconv.Atoi(parts[0])
	endPort, err2 := strconv.Atoi(parts[1])
	if err1 != nil || err2 != nil || startPort < 1 || endPort > 65535 || startPort > endPort {
		return 0, 0, fmt.Errorf("invalid port range values")
	}
	return startPort, endPort, nil
}

// Concurrently scan ports using goroutines
func concurrentScanPorts(target string, startPort, endPort int) []int {
	var openPorts []int
	var wg sync.WaitGroup
	var mu sync.Mutex

	for port := startPort; port <= endPort; port++ {
		wg.Add(1)
		go func(port int) {
			defer wg.Done()
			address := fmt.Sprintf("%s:%d", target, port)
			conn, err := net.DialTimeout("tcp", address, 2*time.Second)
			if err == nil {
				mu.Lock()
				openPorts = append(openPorts, port)
				mu.Unlock()
				conn.Close()
			}
		}(port)
	}
	wg.Wait()
	return openPorts
}

// Concurrently check HTTP vulnerabilities
func concurrentCheckHTTPVulnerabilities(target string, openPorts []int) map[string]string {
	results := make(map[string]string)
	var wg sync.WaitGroup
	var mu sync.Mutex

	for _, port := range openPorts {
		if port == 80 || port == 443 {
			wg.Add(1)
			go func(port int) {
				defer wg.Done()
				protocol := "http"
				if port == 443 {
					protocol = "https"
				}
				url := fmt.Sprintf("%s://%s", protocol, target)
				resp, err := http.Get(url)
				if err != nil {
					mu.Lock()
					results[url] = fmt.Sprintf("Error accessing %s: %v", url, err)
					mu.Unlock()
					return
				}
				defer resp.Body.Close()

				mu.Lock()
				results[url] = analyzeHTTPHeaders(resp)
				mu.Unlock()
			}(port)
		}
	}
	wg.Wait()
	return results
}

// Analyze HTTP headers for vulnerabilities
func analyzeHTTPHeaders(resp *http.Response) string {
	var findings []string

	// Check for security headers
	securityHeaders := []string{"Content-Security-Policy", "Strict-Transport-Security"}
	for _, header := range securityHeaders {
		if _, exists := resp.Header[header]; !exists {
			findings = append(findings, fmt.Sprintf("Missing %s header", header))
		}
	}

	// Check server version
	serverHeader := resp.Header.Get("Server")
	if serverHeader != "" {
		findings = append(findings, fmt.Sprintf("Server: %s", serverHeader))
	} else {
		findings = append(findings, "No Server header found")
	}

	return strings.Join(findings, "; ")
}

// Mock check for vulnerabilities using CVE database
func checkCVEs(openPorts []int) []string {
	// Placeholder: Replace with real-world CVE API calls
	var vulnerabilities []string
	for _, port := range openPorts {
		if port == 80 {
			vulnerabilities = append(vulnerabilities, "CVE-2021-12345: Vulnerable HTTP Server on port 80")
		} else if port == 22 {
			vulnerabilities = append(vulnerabilities, "CVE-2019-6111: SCP command injection on port 22")
		}
	}
	return vulnerabilities
}

// Helper function to check if a slice contains an element
func contains(slice []int, element int) bool {
	for _, item := range slice {
		if item == element {
			return true
		}
	}
	return false
}

// Export scan results to a JSON file
func exportResults(results ScanResult, filename string) {
	file, err := os.Create(filename)
	if err != nil {
		fmt.Printf("Error creating results file: %v\n", err)
		return
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")
	err = encoder.Encode(results)
	if err != nil {
		fmt.Printf("Error writing results to file: %v\n", err)
	}
}
